# Lecture 7 - Sept 29, 2016
* Wait channels are what the OS does
* Conditional variables are what the application uses

## Semaphores to Condition Variables in class problem
``` C
struct lock *sa;
struct lock *sb;
struct lock *lc;
struct cv *cvc;
unsigned int func2s_have_returned;
// At least as many func1's have finished as fun2's have returned

void init(){
  sa = lock_init("A");
  sb = lock_init("B");
  lc = lock_init("C");
  cvc = cv_init("C", lc);
  func2s_have_returned = 0;
}

void func1(){
  lock_acquire(sa);
  funcA();
  lock_release(sa);
  lock_acquire(lc);

  // As long as not in cv_wait, still have the lock
  // cv_wait, releases the lock (so it can be changed) and gets it back -> back to critical section
  while(func2s_have_returned == 0){
      cv_wait(cvc, lc);
  }
  func2s_have_returned--;
  lock_release(lc);
}

// if func2 then func1, then func1 will get blocked by an instance of func2 that already happened
// Need to encode integer value of semaphore
void func2(){
  lock_acquire(sb);
  funcB();
  lock_release(sb);
  lock_acquire(lc);
  func2s_have_returned++;
  cv_signal(cvc, lc);
  lock_release(lc);
}
```

## Deadlocks
* What happens when synchronization goes wrong?
  * Neither thread can make any progress
* It is not the responsibility of the OS to prevent deadlock, it is the responsibility of the application to ensure it is using locks correctly.

### No hold and Wait
* Prevent a thread from allocating new resources if it already has resources.
* A thread may hold multiple resources, but to do so it must make a single request for all of them
* There is no atomic operation for this: no help

### Resource Ordering
* Order the resource types, and require that each thread acquire resources in increasing resource type order.
* Cannot request resources of order < i if it is currently holding resource i.
* It be complicated to ensure this ordering property.
* Not always easy in practice.

## End of synchronization - Summary
* Shared variables, want to
* Enforced with critical sections
* Mutual exclusion (implemented with locks)
* spinlocks don't block (keep the CPU hot).
* Locks block using wait channels
* Semaphores - communicate integers --> producer consumers want to synchronize on size.
* Condition variables - communicate an abstract condition (up to program to determine what that means)
* Deadlock

## In-Class Problem: queuexfer
* Have one giant lock that locks everything (not a good solution)
* Better: Involves resource ordering.

## Processes and System Calls
* **Processes**: multiple unrelated things happening at the same time (don't share any resources).
* A process is an environment in which an application program runs.
  * Includes virtualized resources that it's program can use:
    * 1+ threads
    * virtual memory, used for the program's code and data
    * other resources (i.e. file and socket descriptors)
  * Created and managed by the kernel
  * each program's process isolates it from other programs in other processes.
    * Note doesn't isolate it from other threads in the process
    * Can have the same program (i.e. Chrome) in 2 processes but are completely separate.

### System Calls
* Are the interface between processes and the kernel
* Used by a process to request OS services (probably anything that can't be handled within the processes virtual memory).

### System Call Stack
* Application <--> SysCall Library <--> Kernel

### Kernel Privilege
* Kernel code runs at a higher **execution privilege** than application code.
* Privilege levels are implemented by the CPU.
* Limits access to certain CPU instructions that require higher privilege.
* Kernel implements these function
* Caveat: Application's can't access these functions because they're not privileged and are separate.

### How System Calls Work
* Kernel and Applications in separate memory space --> Applications can't see these kernel functions.
* Only 2 ways to make kernel code runs

  1. **Interrupts**: are generated by devices. Hardware needs attention.
    * causes the hardware to transfer control to a fixed location in memory, where an interrupt handler is locations.
    * Interrupt handlers are part of the kernel (and thus have execution privilege).
  2. **Exceptions**: caused by instruction execution, a running programs needs attention.
    * An instruction on the CPU did something wrong.
    * Jumps to a fixed location, where an exception handler is located.
    * Examples: arithmetic overflows, illegal instructions (not valid or privileged when not in privileged mode), or page faults.
* In MIPS, there is a single handler for both interrupts and exceptions
* There is a kernel register where an exception code is stored

* System calls are caused by the application causing an exception.
* Exception Handler check the exception code to distinguish system calls from other types of exceptions

* How it works in application:
  1. app calls library wrapper function for desired system calls.
  2. library function performs the **syscall** instruction.
  3. kernel exception handler runs
    * Create trap frame to save program state
    * determine exception type (system call)
    * determine which system call is requested.
    * does the work for the call
    * restores application state from the trap frame
    * returns from the exception (and goes back to unprivileged mode).
  4. Library wrapper function finishes and returns from it's call
  5. Application continues execution.
